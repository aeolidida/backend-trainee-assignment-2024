# Тестовое задание для стажёра Backend
## Сервис баннеров
В Авито есть большое количество неоднородного контента, для которого необходимо иметь единую систему управления.  В частности, необходимо показывать разный контент пользователям в зависимости от их принадлежности к какой-либо группе. Данный контент мы будем предоставлять с помощью баннеров.
## Описание задачи
Необходимо реализовать сервис, который позволяет показывать пользователям баннеры, в зависимости от требуемой фичи и тега пользователя, а также управлять баннерами и связанными с ними тегами и фичами.
## Общие вводные
**Баннер** — это документ, описывающий какой-либо элемент пользовательского интерфейса. Технически баннер представляет собой  JSON-документ неопределенной структуры. 
**Тег** — это сущность для обозначения группы пользователей; представляет собой число (ID тега). 
**Фича** — это домен или функциональность; представляет собой число (ID фичи).  
1. Один баннер может быть связан только с одной фичей и несколькими тегами
2. При этом один тег, как и одна фича, могут принадлежать разным баннерам одновременно
3. Фича и тег однозначно определяют баннер

Так как баннеры являются для пользователя вспомогательным функционалом, допускается, если пользователь в течение короткого срока будет получать устаревшую информацию.  При этом существует часть пользователей (порядка 10%), которым обязательно получать самую актуальную информацию. Для таких пользователей нужно предусмотреть механизм получения информации напрямую из БД.
## Условия
1. Используйте этот [API](https://github.com/avito-tech/backend-trainee-assignment-2024/blob/main/api.yaml)
2. Тегов и фичей небольшое количество (до 1000), RPS — 1k, SLI времени ответа — 50 мс, SLI успешности ответа — 99.99%
3. Для авторизации доступов должны использоваться 2 вида токенов: пользовательский и админский.  Получение баннера может происходить с помощью пользовательского или админского токена, а все остальные действия могут выполняться только с помощью админского токена.  
4. Реализуйте интеграционный или E2E-тест на сценарий получения баннера.
5. Если при получении баннера передан флаг use_last_revision, необходимо отдавать самую актуальную информацию.  В ином случае допускается передача информации, которая была актуальна 5 минут назад.
6. Баннеры могут быть временно выключены. Если баннер выключен, то обычные пользователи не должны его получать, при этом админы должны иметь к нему доступ.

## Дополнительные задания:
Эти задания не являются обязательными, но выполнение всех или части из них даст вам преимущество перед другими кандидатами. 
1. Адаптировать систему для значительного увеличения количества тегов и фичей, при котором допускается увеличение времени исполнения по редко запрашиваемым тегам и фичам
2. Провести нагрузочное тестирование полученного решения и приложить результаты тестирования к решению
3. Иногда получается так, что необходимо вернуться к одной из трех предыдущих версий баннера в связи с найденной ошибкой в логике, тексте и т.д. Измените API таким образом, чтобы можно было просмотреть существующие версии баннера и выбрать подходящую версию
4. Добавить метод удаления баннеров по фиче или тегу, время ответа которого не должно превышать 100 мс, независимо от количества баннеров.  В связи с небольшим временем ответа метода, рекомендуется ознакомиться с механизмом выполнения отложенных действий 
5. Реализовать интеграционное или E2E-тестирование для остальных сценариев
6. Описать конфигурацию линтера

## Требования по стеку
- **Язык сервиса:** предпочтительным будет Go, при этом вы можете выбрать любой, удобный вам. 
- **База данных:** предпочтительной будет PostgreSQL, при этом вы можете выбрать любую, удобную вам. 
- Для **деплоя зависимостей и самого сервиса** рекомендуется использовать Docker и Docker Compose.
## Ход решения
Если у вас возникнут вопросы по заданию, ответы на которые вы не найдете в описанных «Условиях», то вы вольны принимать решения самостоятельно.  
В таком случае приложите к проекту README-файл, в котором будет список вопросов и пояснения о том, как вы решили проблему и почему именно выбранным вами способом.
## Оформление решения
Необходимо предоставить публичный git-репозиторий на любом публичном хосте (GitHub / GitLab / etc), содержащий в master/main ветке: 
1. Код сервиса
2. Makefile c командами сборки проекта / Описанная в README.md инструкция по запуску
3. Описанные в README.md вопросы/проблемы, с которыми столкнулись, и ваша логика их решений (если требуется)

## Инструкция по запуску

Следующая команда собирает Docker образ основного приложения и запускает Docker Compose с Postgres, Redis и RabbitMQ для разработки и тестирования.

```
make dev
```

## Примеры запросов 

Для секретного ключа "my_secret_key", указанного в файлах .env.test и .env.dev, подходят следующие токены:

### Admin Token 

```
eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyX2lkIjoxLCJ1c2VyX3R5cGUiOiJhZG1pbiIsImV4cCI6MTcxMzIwMzY4M30.uh8l49l1_JnxUwRDyA_YufIMhede2P5I-8aKtJNFj3k
```

### UserToken

```
eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyX2lkIjoyLCJ1c2VyX3R5cGUiOiJ1c2VyIiwiZXhwIjoxNzEzMjA2MzY1fQ.NxzlMjUogeJvefmhPmVxVZ5IUdb9AIHArn32Hl6p8bc
```

## GET /user_banner

```
curl --location 'localhost:8080/user_banner?tag_id=1&feature_id=2&use_last_revision=false' \
--header 'Token: eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyX2lkIjoxLCJ1c2VyX3R5cGUiOiJhZG1pbiIsImV4cCI6MTcxMzIwMzY4M30.uh8l49l1_JnxUwRDyA_YufIMhede2P5I-8aKtJNFj3k' \
--data ''
```

## GET /banner

```
curl --location 'localhost:8080/banner/' \
--header 'Token: eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyX2lkIjoxLCJ1c2VyX3R5cGUiOiJhZG1pbiIsImV4cCI6MTcxMzIwMzY4M30.uh8l49l1_JnxUwRDyA_YufIMhede2P5I-8aKtJNFj3k' \
--data ''
```

## POST /banner

```
curl --location '127.1.0.0:8080/banner' \
--header 'Token: eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyX2lkIjoxLCJ1c2VyX3R5cGUiOiJhZG1pbiIsImV4cCI6MTcxMzIwMzY4M30.uh8l49l1_JnxUwRDyA_YufIMhede2P5I-8aKtJNFj3k' \
--header 'Content-Type: application/json' \
--data '{
    "tag_ids": [1,2],
    "feature_id" :3, 
    "content": {"title": "new", "text": "some_text", "url": "some_url"},
    "is_active": true
}'
```

## PATCH /banner/{bannerID}

```
curl --location --request PATCH 'localhost:8080/banner/1' \
--header 'Token: eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyX2lkIjoxLCJ1c2VyX3R5cGUiOiJhZG1pbiIsImV4cCI6MTcxMzIwMzY4M30.uh8l49l1_JnxUwRDyA_YufIMhede2P5I-8aKtJNFj3k' \
--header 'Content-Type: application/json' \
--data '{
    "tag_ids": [1,2],
    "feature_id": 6,
    "content": {"title": "changed", "text": "new_text", "url": "some_url"},
    "is_active":true
}'
```

## DELETE /banner/{bannerID}

```
curl --location --request DELETE 'localhost:8080/banner/2' \
--header 'Token: eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyX2lkIjoxLCJ1c2VyX3R5cGUiOiJhZG1pbiIsImV4cCI6MTcxMzIwMzY4M30.uh8l49l1_JnxUwRDyA_YufIMhede2P5I-8aKtJNFj3k'
```

## GET /banner/{bannerID}/versions

```
curl --location 'localhost:8080/banner/1/versions' \
--header 'Token: eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyX2lkIjoxLCJ1c2VyX3R5cGUiOiJhZG1pbiIsImV4cCI6MTcxMzIwMzY4M30.uh8l49l1_JnxUwRDyA_YufIMhede2P5I-8aKtJNFj3k'
```

## POST /banner/{bannerID}/versions/{updatedAt}/restore

```
curl --location --request POST 'localhost:8080/banner/1/versions/1672531320/restore' \
--header 'token: eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyX2lkIjoxLCJ1c2VyX3R5cGUiOiJhZG1pbiIsImV4cCI6MTcxMzIwMzY4M30.uh8l49l1_JnxUwRDyA_YufIMhede2P5I-8aKtJNFj3k'
```

## Проблемы, вопросы, решения

1. Стоит ли создавать под теги и фичи отдельную таблицу? Как мне кажется, если основная задача сервиса — работа с баннерами, и дополнительные сведения о фичах и тегах используются только для ограничений в banner_mappings, то выделение их в отдельные таблицы будет избыточным и усложнит структуру базы данных без дополнительных преимуществ. 

2. Предаполагаю, что за проверку подлинности пользователей и выдачу им пользовательских и административных токенов будет отвечать отдельный сервис. Сервис баннеров, насколько мне понятно, должен заниматься только валидацией токена (проверить подпись и срок действия) и вытащить оттуда тип пользователя (пользовательский или административный). Считаю, что для подписи токена используется HS256, а payload выглядит следующим образом 

```
{
    "user_id": 123,
    "user_type": "user" или "admin",
    "exp": 1681869600 
}
```

Метод GenerateToken добавлен для тестов.

3. Должен ли этот сервис валидировать JSON, который ему приходит? Мне кажется, что да - если сервис в том числе отвечает за хранение баннеров, то, наверное, должен и валидировать перед добавлением.

4. В дополнительном задании 3, насколько мне понятно, идет речь именно о поле content, но не о предыдущих группах пользователей, например. Поэтому у меня не хранятся прошлые наборы тегов и прошлые feature.

5. Удаление старых версий в banner_history (так, чтобы оставались только три последние версии) сделано с помощью триггеров. Несмотря на то, что логика приложения размазывается и на базу данных, решение довольно простое и не сильно затратное.

6. Фикстуры для e2e и integration/repo лежат отдельно, хотя они одинаковые, потому что если в один что-то захочется добавить (с целью, например, протестировать новый функционал), то не хотелось бы, чтобы это влияло на другой тест.

7. Решение добавить поле is_active в banner было плохое.


